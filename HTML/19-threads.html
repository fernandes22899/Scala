<!DOCTYPE html>
<!-- Generated from 901-threads.md; DO NOT EDIT! -->
<html lang="en">
<head>
  <meta name="generator" content="pandoc">
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>19-threads</title>
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans"/>
  <link rel="stylesheet" type="text/css" href="notes.css"/>
  </head>

<body>
<h2 id="multi-threaded-programs-in-java-and-scala">Multi-threaded programs in Java and Scala</h2>
<h3 id="single-threaded-programs">Single threaded programs</h3>
<p>Through the <code>java.lang.Thread</code> class, Java has included threads from the beginning. A <em>thread</em>—short for <em>thread of execution</em>—represents the execution of a program. By default, Java (and Scala) programs are <em>single-threaded</em>: One thread executes the entire program from beginning to end. Additional threads can be created so that multiple executions of a program take place concurrently, thus introducing <em>parallelism</em> in a program. Scala programs can use the Java <code>Thread</code> class directly to create threads.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">object</span> Demo <span class="kw">extends</span> App {</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a>  <span class="kw">def</span> println[A](message: A): Unit = {</span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="fu">println</span>(<span class="st">&quot;%1$s at %2$TT.%2$TL: %3$s&quot;</span><span class="fu">.format</span>(Thread.currentThread.getName,</span>
<span id="cb1-5"><a href="#cb1-5"></a>                                               System.<span class="fu">currentTimeMillis</span>,</span>
<span id="cb1-6"><a href="#cb1-6"></a>                                               message))</span>
<span id="cb1-7"><a href="#cb1-7"></a>  }</span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a>  <span class="fu">println</span>(<span class="st">&quot;START&quot;</span>)</span>
<span id="cb1-10"><a href="#cb1-10"></a>  <span class="fu">println</span>(<span class="st">&quot;END&quot;</span>)</span>
<span id="cb1-11"><a href="#cb1-11"></a>}</span></code></pre></div>
<p>The code above produces the following output:</p>
<pre><code>main at XX:XX:32.032: START
main at XX:XX:32.161: END</code></pre>
<p>The strings <code>"START"</code> and <code>"END"</code> are printed using a user-defined function that adds the name of the thread calling <code>println</code> (using static method <code>currentThread</code> from the Java <code>Thread</code> class) and the time at which the printing occurs (using method <code>currentTimeMillis</code>).<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> We can see that a thread named <code>main</code> executes both print statements within a few milliseconds of each other. This thread is the one thread given to any application as it starts (using the <code>App</code> trait or a <code>main</code> method).</p>
<h3 id="creating-and-starting-threads">Creating and starting threads</h3>
<p>Additional threads can be created by instantiating the <code>Thread</code> class. Its constructor takes an instance of type <code>Runnable</code>, which is a Java interface with a single <code>void</code> method <code>run()</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">import</span> org.<span class="fu">scalactic</span>.<span class="fu">TimesOnInt</span>._  <span class="co">// enables &quot;n times {}&quot; loops</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">class</span> <span class="fu">Printer</span>(c: Char) <span class="kw">extends</span> Runnable {</span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="kw">def</span> <span class="fu">run</span>(): Unit = {</span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="dv">5</span> times <span class="fu">println</span>(c)</span>
<span id="cb3-6"><a href="#cb3-6"></a>  }</span>
<span id="cb3-7"><a href="#cb3-7"></a>}</span></code></pre></div>
<p>This runnable prints a single character 5 times. Instances of this class can be used to create threads:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">object</span> Demo <span class="kw">extends</span> App {</span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="fu">println</span>(<span class="st">&quot;START&quot;</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="kw">val</span> r1 = <span class="kw">new</span> <span class="fu">Printer</span>(<span class="ch">&#39;+&#39;</span>)</span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="kw">val</span> r2 = <span class="kw">new</span> <span class="fu">Printer</span>(<span class="ch">&#39;*&#39;</span>)</span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a>  <span class="kw">val</span> t1 = <span class="kw">new</span> Thread(r1, <span class="st">&quot;T1&quot;</span>)</span>
<span id="cb4-8"><a href="#cb4-8"></a>  <span class="kw">val</span> t2 = <span class="kw">new</span> Thread(r2, <span class="st">&quot;T2&quot;</span>)</span>
<span id="cb4-9"><a href="#cb4-9"></a></span>
<span id="cb4-10"><a href="#cb4-10"></a>  t1.<span class="fu">start</span>()</span>
<span id="cb4-11"><a href="#cb4-11"></a>  t2.<span class="fu">start</span>()</span>
<span id="cb4-12"><a href="#cb4-12"></a></span>
<span id="cb4-13"><a href="#cb4-13"></a>  <span class="fu">println</span>(<span class="st">&quot;END&quot;</span>)</span>
<span id="cb4-14"><a href="#cb4-14"></a>}</span></code></pre></div>
<p>This program produces outputs that may look like this:</p>
<pre><code>main at XX:XX:48.875: START
main at XX:XX:49.005: END
T1 at XX:XX:49.011: +
T2 at XX:XX:49.011: *
T1 at XX:XX:49.012: +
T2 at XX:XX:49.012: *
T1 at XX:XX:49.012: +
T2 at XX:XX:49.012: *
T2 at XX:XX:49.013: *
T1 at XX:XX:49.013: +
T2 at XX:XX:49.013: *
T1 at XX:XX:49.013: +</code></pre>
<p>Several things can be observed from this run:</p>
<ul>
<li><p>Threads can be named by passing a string to the class constructor (there is also a <code>setName</code> method). If no name is set, a default name is created by the runtime system. It’s a good idea to name threads explicitly because it can held debugging (in particular, see the discussion of <em>thread dumps</em> below).</p></li>
<li><p>The <code>start</code> method starts a thread. This effectively introduces parallelism in the system: The newly started thread begins to run in parallel with other threads (including the thread that created it). The <code>start</code> method returns immediately.</p></li>
<li><p>The main thread reaches the end ot its code and terminates while threads <code>T1</code> and <code>T2</code> are still starting. The JVM continues to run until these two threads are finished. A JVM stops when all its <em>non-daemon</em> threads are terminated. Threads can be started in daemon or non-daemon mode. The default, normal mode is non-daemon.</p>
<p>If needed, the main thread can wait for <code>T1</code> and <code>T2</code> to terminate by using Java method <code>join</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb6-1"><a href="#cb6-1"></a>  ...</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a>  t1.<span class="fu">join</span>()</span>
<span id="cb6-4"><a href="#cb6-4"></a>  t2.<span class="fu">join</span>()</span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a>  <span class="fu">println</span>(<span class="st">&quot;END&quot;</span>)</span>
<span id="cb6-7"><a href="#cb6-7"></a>}</span></code></pre></div>
<p>This variant of the program would display all the <code>*</code> and <code>+</code> <em>before</em> the <code>END</code> message.</p></li>
<li><p>The <code>*</code> and <code>+</code> characters are interleaved on the terminal. The exact interleaving is unpredictable. It depends on the order in which the threads can access the terminal for printing, which depends in part on how threads are scheduled for execution by the operating system in the presence of other activities.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> This is not controlled by the user or even by the JVM and tends to vary from run to run. Another run of the same program may produce a different output:</p>
<pre><code>main at XX:XX:34.828: START
main at XX:XX:34.996: END
T2 at XX:XX:35.002: *
T1 at XX:XX:35.002: +
T2 at XX:XX:35.002: *
T1 at XX:XX:35.002: +
T2 at XX:XX:35.002: *
T1 at XX:XX:35.002: +
T1 at XX:XX:35.003: +
T2 at XX:XX:35.003: *
T1 at XX:XX:35.003: +
T2 at XX:XX:35.003: *</code></pre>
<p>This run outputs the characters in <code>*+*+*++*+*</code> order instead of <code>+*+*+**+*+</code> before.</p></li>
</ul>
<p>This last point is crucial: Multi-threaded programs tend to exhibit <em>nondeterministic</em> behavior: Identical runs (same program on the same data) can produce different behaviors. This makes testing and debugging much more challenging than with single-threaded programs.</p>
<h3 id="creating-threads-using-lambdas">Creating threads using lambdas</h3>
<p>Java 8’s lambdas can be used as targets of <em>functional interfaces</em>, including <code>Runnable</code>, and thus can be used to create threads:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">// this is Java</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="dt">void</span> <span class="fu">compute</span>() { <span class="kw">... </span>}</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="dt">void</span> <span class="fu">apply</span>(<span class="dt">int</span> index) { <span class="kw">... </span>}</span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="bu">Thread</span> t = <span class="kw">new</span> <span class="bu">Thread</span>(() -&gt; <span class="fu">apply</span>(<span class="dv">42</span>), <span class="st">&quot;MyApplyThread&quot;</span>);</span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="bu">Thread</span> t = <span class="kw">new</span> <span class="bu">Thread</span>(() -&gt; <span class="fu">compute</span>(), <span class="st">&quot;MyComputeThread&quot;</span>);</span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="bu">Thread</span> t = <span class="kw">new</span> <span class="bu">Thread</span>(<span class="kw">this</span>::compute, <span class="st">&quot;MyComputeThread&quot;</span>);</span></code></pre></div>
<p>The last two are equivalent.</p>
<p>Starting with Scala 2.12, Scala’s function literals can also be used to target Java functional interfaces:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">def</span> <span class="fu">compute</span>(): Unit = ...</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">def</span> <span class="fu">apply</span>(index: Int): Unit = ...</span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="kw">val</span> t = <span class="kw">new</span> Thread(() =&gt; <span class="fu">apply</span>(<span class="dv">42</span>), <span class="st">&quot;MyApplyThread&quot;</span>)</span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="kw">val</span> t = <span class="kw">new</span> Thread(() =&gt; <span class="fu">compute</span>(), <span class="st">&quot;MyComputeThread&quot;</span>)</span></code></pre></div>
<p>However, despite the availability of <span class="math inline"><em>η</em></span>-conversion in Scala, neither <code>new Thread(compute)</code> nor <code>new Thread(compute _)</code> works.</p>
<h3 id="atomicity">Atomicity</h3>
<p>When multiple threads access <em>shared mutable data</em>, strange things can happen, unless these data were designed to be <em>thread-safe</em>. As a simple example, consider the case of two threads sharing a counter:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb10-1"><a href="#cb10-1"></a>  <span class="kw">var</span> shared = <span class="dv">0</span></span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="kw">class</span> <span class="fu">Adder</span>(n: Int) <span class="kw">extends</span> Runnable {</span>
<span id="cb10-4"><a href="#cb10-4"></a>    <span class="kw">def</span> <span class="fu">run</span>(): Unit = {</span>
<span id="cb10-5"><a href="#cb10-5"></a>      n times {</span>
<span id="cb10-6"><a href="#cb10-6"></a>        shared += <span class="dv">1</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>      }</span>
<span id="cb10-8"><a href="#cb10-8"></a>    }</span>
<span id="cb10-9"><a href="#cb10-9"></a>  }</span>
<span id="cb10-10"><a href="#cb10-10"></a></span>
<span id="cb10-11"><a href="#cb10-11"></a>  <span class="kw">val</span> a1 = <span class="kw">new</span> <span class="fu">Adder</span>(<span class="dv">5</span>)</span>
<span id="cb10-12"><a href="#cb10-12"></a>  <span class="kw">val</span> a2 = <span class="kw">new</span> <span class="fu">Adder</span>(<span class="dv">5</span>)</span>
<span id="cb10-13"><a href="#cb10-13"></a></span>
<span id="cb10-14"><a href="#cb10-14"></a>  <span class="kw">val</span> t1 = <span class="kw">new</span> Thread(a1, <span class="st">&quot;T1&quot;</span>)</span>
<span id="cb10-15"><a href="#cb10-15"></a>  <span class="kw">val</span> t2 = <span class="kw">new</span> Thread(a2, <span class="st">&quot;T2&quot;</span>)</span>
<span id="cb10-16"><a href="#cb10-16"></a></span>
<span id="cb10-17"><a href="#cb10-17"></a>  t1.<span class="fu">start</span>()</span>
<span id="cb10-18"><a href="#cb10-18"></a>  t2.<span class="fu">start</span>()</span>
<span id="cb10-19"><a href="#cb10-19"></a></span>
<span id="cb10-20"><a href="#cb10-20"></a>  t1.<span class="fu">join</span>()</span>
<span id="cb10-21"><a href="#cb10-21"></a>  t2.<span class="fu">join</span>()</span>
<span id="cb10-22"><a href="#cb10-22"></a></span>
<span id="cb10-23"><a href="#cb10-23"></a>  <span class="fu">println</span>(shared)</span></code></pre></div>
<p>The <code>println(shared)</code> statement takes place after both threads are terminated and should reflect all the increments they applied to the shared counter (5 each). However, although some runs do produce the expected value 10, some don’t. When running the program above on my laptop 10 times, it produced the following outputs: 10, 6, 10, 6, 5, 10, 10, 10, 5 and 10. Again, we observe the typical nondeterminism of multi-threaded programs.</p>
<p>The reason some increments are missing in some runs is that the operation <code>shared += 1</code> is not <em>atomic</em>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> It actually consists of (at least) three steps:</p>
<ul>
<li><em>read</em> the current value of <code>shared</code> from memory into a register (local to the thread);</li>
<li>increment the register;</li>
<li><em>write</em> the value of the register back into memory.</li>
</ul>
<p>The following scenario is therefore possible:</p>
<ul>
<li>Variable <code>shared</code> is equal to 0 as the threads start.</li>
<li>Thread <code>T1</code> reads <code>shared</code> into a register <code>r1</code> (<code>r1==0</code>).</li>
<li>Thread <code>T1</code> increments register <code>r1</code> (<code>r1==1</code>).</li>
<li>Thread <code>T2</code> reads <code>shared</code> into a register <code>r2</code> (<code>r2==0</code>).</li>
<li>Thread <code>T2</code> increments register <code>r2</code> (<code>r2==1</code>).</li>
<li>Thread <code>T2</code> writes back register <code>r2</code> into memory (<code>shared==1</code>).</li>
<li>Thread <code>T1</code> writes back register <code>r1</code> into memory (<code>shared==1</code>).</li>
</ul>
<p>Both increment operations are now complete, but the value of <code>shared</code> is 1, not 2, and one increment has been lost.</p>
<h3 id="thread-safe-code">Thread safe code</h3>
<p>Most methods consist of multiple statements (especially at the machine-code level), which can be interleaved in arbitrary ways when the methods are called by multiple threads. Objects that were not designed to handle these interleavings are likely to break when shared among multiple threads. This is true in particular of most data structures in <code>java.util</code> and in <code>scala.collection.mutable</code>. The example above can be modified to make the two threads share an instance of <code>ArrayBuffer</code> instead of an integer:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb11-1"><a href="#cb11-1"></a>  <span class="kw">val</span> shared = <span class="kw">new</span> ArrayBuffer[String]</span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span class="kw">class</span> <span class="fu">Adder</span>(n: Int, s: String) <span class="kw">extends</span> Runnable {</span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span class="kw">def</span> <span class="fu">run</span>(): Unit = {</span>
<span id="cb11-5"><a href="#cb11-5"></a>      n times {</span>
<span id="cb11-6"><a href="#cb11-6"></a>        shared += s</span>
<span id="cb11-7"><a href="#cb11-7"></a>      }</span>
<span id="cb11-8"><a href="#cb11-8"></a>    }</span>
<span id="cb11-9"><a href="#cb11-9"></a>  }</span>
<span id="cb11-10"><a href="#cb11-10"></a></span>
<span id="cb11-11"><a href="#cb11-11"></a>  <span class="kw">val</span> a1 = <span class="kw">new</span> <span class="fu">Adder</span>(<span class="dv">10</span>, <span class="st">&quot;foo&quot;</span>)</span>
<span id="cb11-12"><a href="#cb11-12"></a>  <span class="kw">val</span> a2 = <span class="kw">new</span> <span class="fu">Adder</span>(<span class="dv">10</span>, <span class="st">&quot;bar&quot;</span>)</span>
<span id="cb11-13"><a href="#cb11-13"></a></span>
<span id="cb11-14"><a href="#cb11-14"></a>  <span class="kw">val</span> t1 = <span class="kw">new</span> Thread(a1, <span class="st">&quot;T1&quot;</span>)</span>
<span id="cb11-15"><a href="#cb11-15"></a>  <span class="kw">val</span> t2 = <span class="kw">new</span> Thread(a2, <span class="st">&quot;T2&quot;</span>)</span>
<span id="cb11-16"><a href="#cb11-16"></a></span>
<span id="cb11-17"><a href="#cb11-17"></a>  t1.<span class="fu">start</span>()</span>
<span id="cb11-18"><a href="#cb11-18"></a>  t2.<span class="fu">start</span>()</span>
<span id="cb11-19"><a href="#cb11-19"></a></span>
<span id="cb11-20"><a href="#cb11-20"></a>  t1.<span class="fu">join</span>()</span>
<span id="cb11-21"><a href="#cb11-21"></a>  t2.<span class="fu">join</span>()</span>
<span id="cb11-22"><a href="#cb11-22"></a></span>
<span id="cb11-23"><a href="#cb11-23"></a>  <span class="fu">println</span>(shared.<span class="fu">length</span>)</span></code></pre></div>
<p>The program displays the length of a shared buffer after both threads have each added ten strings to it. Some runs do display 20 but, like before, some produce smaller values, indicating that some strings were not added to the buffer. Also, some runs fail with an exception:</p>
<pre><code>Exception in thread &quot;T2&quot; java.lang.ArrayIndexOutOfBoundsException: 16
    at scala.collection.mutable.ArrayBuffer.$plus$eq(ArrayBuffer.scala:85)</code></pre>
<p>or:</p>
<pre><code>Exception in thread &quot;T1&quot; java.lang.ArrayIndexOutOfBoundsException
    at java.lang.System.arraycopy(Native Method)</code></pre>
<p>(These happen when the buffer, created by default with a capacity of 16, needs to be extended.)</p>
<p>Note that it is fairly easy to trigger incorrect behaviors on these examples because the threads hit the shared value as fast as possible without any intervening operations. Real systems, on the other hand, can contain code that accesses shared data only occasionally and only exhibits incorrect behavior extremely rarely (e.g., one run in a million) and only on some hardware/JVM combinations, making testing and debugging of multi-threaded programs extremely difficult.</p>
<h3 id="bringing-back-atomicity-by-locking">Bringing back atomicity by locking</h3>
<p>One of the most commonly used techniques to ensure thread-safety is the use of <em>locking</em>. The basic principle is to guard portions of code (like methods) with <em>locks</em> that need to be acquired to run the code. The most common form of lock is the <em>exclusive lock</em>, which can only be acquired by one thread at a time. The idea is that, instead of executing <code>shared += s</code> on the <code>ArrayBuffer</code> above, threads should be executing instead:</p>
<pre><code>// this is pseudo-code
exclusiveLock.lock()
shared += s
exclusiveLock.unlock()</code></pre>
<p>Because the lock is exclusive, no two threads can be inside method <code>+=</code> at the same time. This allows one thread to complete the execution of the method before another threads starts it again. In effect, the method appears to be <em>atomic</em>: It is not possible for a thread to partially run the method and have another thread come in.</p>
<p>Both Java and Scala have exclusive locks readily available (Scala’s mechanism is built on top of Java’s; they are the same at the level of the JVM). In Java, <code>synchronized</code> is a keyword that can be used to create <em>synchronized blocks</em> or <em>synchronized methods</em>. The pseudo-code above could be written in Java:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb15-1"><a href="#cb15-1"></a><span class="co">// this is Java</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="kw">synchronized</span> (lock) {</span>
<span id="cb15-3"><a href="#cb15-3"></a>  shared.<span class="fu">add</span>(s);</span>
<span id="cb15-4"><a href="#cb15-4"></a>}</span></code></pre></div>
<p>What <code>lock</code> actually is does not matter much. Any Java/Scala object can be used as a lock. What matters is that the object is shared among threads and that all the threads synchronize by locking the <em>same</em> object. Having two threads lock on two <em>different</em> objects would be a mistake, since they could both acquire their lock at the same time.</p>
<p>Alternatively, <code>synchronized</code> can be applied to a Java method, turning the entire body into a synchronized block:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb16-1"><a href="#cb16-1"></a><span class="co">// this is Java</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">synchronized</span> <span class="dt">void</span> <span class="fu">lockedAdd</span>(<span class="bu">String</span> s) {</span>
<span id="cb16-3"><a href="#cb16-3"></a>  shared.<span class="fu">add</span>(s);</span>
<span id="cb16-4"><a href="#cb16-4"></a>}</span></code></pre></div>
<p>Note that, when synchronizing a (non-static) method, the lock used is <code>this</code>, which may or may not be acceptable. In particular, it has to be shared among the synchronizing threads. Here, this means that method <code>lockedAdd</code> must be associated with a single object that contains <code>shared</code>, <em>not</em> with class <code>Adder</code>, since each thread has its own adder.</p>
<p>In Scala, <code>synchronized</code> is a method of class <code>AnyRef</code>. The Java code above can be written in Scala:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb17-1"><a href="#cb17-1"></a><span class="co">// synchronizing on lock</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>lock.<span class="fu">synchronized</span>(shared += s)</span></code></pre></div>
<p>or:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb18-1"><a href="#cb18-1"></a><span class="co">// synchronizing on lock</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>lock.<span class="fu">synchronized</span> {</span>
<span id="cb18-3"><a href="#cb18-3"></a>  shared += s</span>
<span id="cb18-4"><a href="#cb18-4"></a>}</span></code></pre></div>
<p>or:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb19-1"><a href="#cb19-1"></a><span class="co">// synchronizing on shared itself</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>shared.<span class="fu">synchronized</span> {</span>
<span id="cb19-3"><a href="#cb19-3"></a>  shared += s</span>
<span id="cb19-4"><a href="#cb19-4"></a>}</span></code></pre></div>
<p>or:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb20-1"><a href="#cb20-1"></a><span class="co">// synchronizing on &#39;this&#39;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="kw">def</span> <span class="fu">lockedAdd</span>(s: String) = synchronized {</span>
<span id="cb20-3"><a href="#cb20-3"></a>  shared += s</span>
<span id="cb20-4"><a href="#cb20-4"></a>}</span></code></pre></div>
<h3 id="mutual-exclusion">Mutual exclusion</h3>
<p>In the discussion above, <code>synchronized</code> was used to prevent multiple threads from entering the <em>same</em> method. In general, what is needed is to prevent multiple threads from accessing the same <em>object</em>, even via different methods:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">class</span> SafeCounter {</span>
<span id="cb21-2"><a href="#cb21-2"></a>  </span>
<span id="cb21-3"><a href="#cb21-3"></a>  <span class="kw">private</span> <span class="kw">var</span> count = <span class="dv">0</span></span>
<span id="cb21-4"><a href="#cb21-4"></a>  </span>
<span id="cb21-5"><a href="#cb21-5"></a>  <span class="kw">def</span> <span class="fu">increment</span>() = synchronized {</span>
<span id="cb21-6"><a href="#cb21-6"></a>    count += <span class="dv">1</span></span>
<span id="cb21-7"><a href="#cb21-7"></a>  }</span>
<span id="cb21-8"><a href="#cb21-8"></a></span>
<span id="cb21-9"><a href="#cb21-9"></a>  <span class="kw">def</span> <span class="fu">decrement</span>() = synchronized {</span>
<span id="cb21-10"><a href="#cb21-10"></a>    count -= <span class="dv">1</span></span>
<span id="cb21-11"><a href="#cb21-11"></a>  }</span>
<span id="cb21-12"><a href="#cb21-12"></a>  </span>
<span id="cb21-13"><a href="#cb21-13"></a>  <span class="kw">def</span> <span class="fu">get</span>() = <span class="fu">synchronized</span>(count)</span>
<span id="cb21-14"><a href="#cb21-14"></a>}</span></code></pre></div>
<p>In this example, the use of <code>synchronized</code> prevents multiple threads from entering the <code>increment</code> method at the same time, but also from one thread to be inside <code>increment</code> while another is inside <code>decrement</code>. If allowed, this scenario would cause problems similar to multiple threads incrementing at the same time (e.g., lost updates). With proper synchronization, methods <code>increment</code> and <code>decrement</code> have become <em>mutually exclusive</em>.</p>
<h3 id="immutable-objects">Immutable objects</h3>
<p>All the examples above focus on <em>shared mutable data</em>. They are not naturally thread-safe because of <em>write/write</em> and <em>read/write</em> concurrency. On the other hand, <em>immutable data</em>, which can only be read, are naturally thread-safe. For example, multiple threads can call all sorts of methods on a shared Scala <code>List</code> without any synchronization, due to the immutability of lists. This is another benefit of using immutable data structure. In general, concurrent programming tries to maximize the use of immutable objects (using <code>final</code> fields in Java and relying on <code>scala.collection.immutable</code> in Scala).</p>
<h3 id="encapsulating-synchronization-policies">Encapsulating synchronization policies</h3>
<p>Class <code>SafeCounter</code> <em>encapsulates</em> its own synchronization policy (which is to lock on <code>this</code>). This makes it possible for client code to freely call <code>increment</code>, <code>decrement</code> and <code>get</code> from any thread without additional synchronization (instances of <code>SafeCounter</code> are said to be <em>thread-safe</em>). The <code>Adder</code> example can be rewritten to rely on a thread-safe buffer implemented as follows:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">class</span> SafeBuffer {</span>
<span id="cb22-2"><a href="#cb22-2"></a></span>
<span id="cb22-3"><a href="#cb22-3"></a>  <span class="kw">private</span> <span class="kw">val</span> buffer = ArrayBuffer.<span class="fu">empty</span>[String]</span>
<span id="cb22-4"><a href="#cb22-4"></a></span>
<span id="cb22-5"><a href="#cb22-5"></a>  <span class="kw">def</span> +=(s: String): Unit = synchronized {</span>
<span id="cb22-6"><a href="#cb22-6"></a>    buffer += s</span>
<span id="cb22-7"><a href="#cb22-7"></a>  }</span>
<span id="cb22-8"><a href="#cb22-8"></a></span>
<span id="cb22-9"><a href="#cb22-9"></a>  <span class="kw">def</span> length: Int = synchronized {</span>
<span id="cb22-10"><a href="#cb22-10"></a>    buffer.<span class="fu">length</span></span>
<span id="cb22-11"><a href="#cb22-11"></a>  }</span>
<span id="cb22-12"><a href="#cb22-12"></a>}</span></code></pre></div>
<p>All accesses to the <code>ArrayBuffer</code> are guarded by locking on <code>this</code>. It is sometimes preferable to lock on a <em>private</em> object in order to guarantee that threads do not misuse the synchronization policy, as in:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">val</span> b = <span class="kw">new</span> SafeBuffer</span>
<span id="cb23-2"><a href="#cb23-2"></a>b.<span class="fu">synchronize</span> {</span>
<span id="cb23-3"><a href="#cb23-3"></a>  <span class="co">// do lengthy operations, like I/O</span></span>
<span id="cb23-4"><a href="#cb23-4"></a>}</span></code></pre></div>
<p>This would prevent other threads from calling <code>+=</code> or <code>length</code> on buffer <code>b</code>, since these methods require locking on <code>b</code> itself. A private object can be used as the lock to avoid this problem:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">class</span> SafeBuffer {</span>
<span id="cb24-2"><a href="#cb24-2"></a></span>
<span id="cb24-3"><a href="#cb24-3"></a>  <span class="kw">private</span> <span class="kw">val</span> buffer = ArrayBuffer.<span class="fu">empty</span>[String]</span>
<span id="cb24-4"><a href="#cb24-4"></a></span>
<span id="cb24-5"><a href="#cb24-5"></a>  <span class="kw">def</span> +=(s: String): Unit = buffer.<span class="fu">synchronized</span> {</span>
<span id="cb24-6"><a href="#cb24-6"></a>    buffer += s</span>
<span id="cb24-7"><a href="#cb24-7"></a>  }</span>
<span id="cb24-8"><a href="#cb24-8"></a></span>
<span id="cb24-9"><a href="#cb24-9"></a>  <span class="kw">def</span> length: Int = buffer.<span class="fu">synchronized</span> {</span>
<span id="cb24-10"><a href="#cb24-10"></a>    buffer.<span class="fu">length</span></span>
<span id="cb24-11"><a href="#cb24-11"></a>  }</span>
<span id="cb24-12"><a href="#cb24-12"></a>}</span></code></pre></div>
<p>All accesses now need locking on the <code>ArrayBuffer</code> inside <code>SafeBuffer</code> instead of the <code>SafeBuffer</code> instance itself.</p>
<p>Note that <code>buffer</code> is defined here as a <code>val</code>. Locking on a <code>var</code>, even private, is likely to lead to problems when the <code>var</code> is reassigned. Consider a variant of the buffer that uses an immutable list:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb25-1"><a href="#cb25-1"></a><span class="co">// Don&#39;t do this!</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="kw">class</span> SafeBuffer {</span>
<span id="cb25-3"><a href="#cb25-3"></a></span>
<span id="cb25-4"><a href="#cb25-4"></a>  <span class="kw">private</span> <span class="kw">var</span> buffer = List.<span class="fu">empty</span>[String]</span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a>  <span class="kw">def</span> +=(s: String): Unit = buffer.<span class="fu">synchronized</span> {</span>
<span id="cb25-7"><a href="#cb25-7"></a>    buffer ::= s</span>
<span id="cb25-8"><a href="#cb25-8"></a>  }</span>
<span id="cb25-9"><a href="#cb25-9"></a></span>
<span id="cb25-10"><a href="#cb25-10"></a>  <span class="kw">def</span> length: Int = buffer.<span class="fu">synchronized</span> {</span>
<span id="cb25-11"><a href="#cb25-11"></a>    buffer.<span class="fu">length</span></span>
<span id="cb25-12"><a href="#cb25-12"></a>  }</span>
<span id="cb25-13"><a href="#cb25-13"></a>}</span></code></pre></div>
<p>The line <code>buffer ::= s</code> is actually a reassignment to the <code>var</code> (<code>buffer = s :: buffer</code>) with a new list. Concurrent calls to <code>+=</code> could end up synchronizing on <em>different</em> objects, thus breaking the desired mutual exclusion. Consider the following scenario:</p>
<ul>
<li>Thread <code>T1</code> calls <code>+=</code> and acquire the lock on the current value of <code>buffer</code>, say <code>b1</code>.</li>
<li>While <code>T1</code> is inside <code>+=</code>, thread <code>T2</code> tries to call <code>+=</code> and is blocked because the lock on <code>b1</code> is not available.</li>
<li>Thread <code>T1</code> completes its call to <code>+=</code> by replacing <code>b1</code> with a new object <code>b2</code> (built as <code>s :: b1</code>) and releases the lock on <code>b1</code>.</li>
<li>Thread <code>T2</code> can now enter the body of <code>+=</code> since <code>b1</code> has been unlocked.</li>
<li>Thread <code>T1</code> initiates a second call to <code>+=</code>. It acquires the lock on <code>b2</code> and enters the body of the method.</li>
<li><code>T1</code> and <code>T2</code> are now inside the <code>+=</code> method at the same time, and can write variable <code>buffer</code> concurrently, which could cause lost updates to the buffer.</li>
</ul>
<p>Instead, class <code>SafeBuffer</code> should be locking on <code>this</code>, or on a <em>constant</em> private object, as in:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">class</span> SafeBuffer {</span>
<span id="cb26-2"><a href="#cb26-2"></a></span>
<span id="cb26-3"><a href="#cb26-3"></a>  <span class="kw">private</span> <span class="kw">val</span> lock = <span class="kw">new</span> Object</span>
<span id="cb26-4"><a href="#cb26-4"></a></span>
<span id="cb26-5"><a href="#cb26-5"></a>  <span class="kw">private</span> <span class="kw">var</span> buffer = List.<span class="fu">empty</span>[String]</span>
<span id="cb26-6"><a href="#cb26-6"></a></span>
<span id="cb26-7"><a href="#cb26-7"></a>  <span class="kw">def</span> +=(s: String): Unit = lock.<span class="fu">synchronized</span> {</span>
<span id="cb26-8"><a href="#cb26-8"></a>    buffer ::= s</span>
<span id="cb26-9"><a href="#cb26-9"></a>  }</span>
<span id="cb26-10"><a href="#cb26-10"></a></span>
<span id="cb26-11"><a href="#cb26-11"></a>  <span class="kw">def</span> length: Int = lock.<span class="fu">synchronized</span> {</span>
<span id="cb26-12"><a href="#cb26-12"></a>    buffer.<span class="fu">length</span></span>
<span id="cb26-13"><a href="#cb26-13"></a>  }</span>
<span id="cb26-14"><a href="#cb26-14"></a>}</span></code></pre></div>
<p>This approach, creating a small <code>lock</code> object for synchronization purposes, could also be used in the <code>SafeBuffer</code> class based on <code>ArrayBuffer</code>.</p>
<h3 id="JMM">Java Memory Model</h3>
<p>In the <code>SafeCounter</code> example, method <code>get</code> was also synchronized and made exclusive from methods <code>increment</code> and <code>decrement</code>. One might wonder if this is necessary. After all, what could happen if a thread <em>reads</em> <code>count</code> while another thread updates it? It is a common mistake to think that only <em>write</em> accesses to shared data need to be synchronized. Read accesses <em>must</em> be synchronized as well, <em>even when atomicity is not an issue</em>. Here, for instance, atomicity is not an issue (reading <code>count</code> will return the value before an increment/decrement or after the increment/decrement; there is no in-between). Still, it is absolutely necessary to synchronize method <code>get</code> due to the fact that the <em>Java Memory Model (JMM)</em> is not <em>sequentially consistent</em>. A full discussion of the JMM is beyond the scope of these notes. One need only to remember a simple rule: <em>Every access (read or write) to shared mutable data must be synchronized (on the same lock).</em></p>
<p>To emphasize this point, consider the following Scala program:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">var</span> done = <span class="kw">false</span></span>
<span id="cb27-2"><a href="#cb27-2"></a></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="kw">class</span> Runner <span class="kw">extends</span> Runnable {</span>
<span id="cb27-4"><a href="#cb27-4"></a>  <span class="kw">def</span> <span class="fu">run</span>(): Unit = {</span>
<span id="cb27-5"><a href="#cb27-5"></a>    <span class="kw">while</span> (!done) {</span>
<span id="cb27-6"><a href="#cb27-6"></a>      <span class="co">// do something</span></span>
<span id="cb27-7"><a href="#cb27-7"></a>    }</span>
<span id="cb27-8"><a href="#cb27-8"></a>  }</span>
<span id="cb27-9"><a href="#cb27-9"></a>}</span>
<span id="cb27-10"><a href="#cb27-10"></a></span>
<span id="cb27-11"><a href="#cb27-11"></a><span class="kw">val</span> r = <span class="kw">new</span> Runner</span>
<span id="cb27-12"><a href="#cb27-12"></a><span class="kw">val</span> t = <span class="kw">new</span> Thread(r, <span class="st">&quot;Runner&quot;</span>)</span>
<span id="cb27-13"><a href="#cb27-13"></a></span>
<span id="cb27-14"><a href="#cb27-14"></a>t.<span class="fu">start</span>()</span>
<span id="cb27-15"><a href="#cb27-15"></a><span class="fu">println</span>(<span class="st">&quot;runner started at &quot;</span> + <span class="kw">new</span> java.<span class="fu">util</span>.<span class="fu">Date</span>())</span>
<span id="cb27-16"><a href="#cb27-16"></a></span>
<span id="cb27-17"><a href="#cb27-17"></a>done = <span class="kw">true</span>        <span class="co">// request termination</span></span>
<span id="cb27-18"><a href="#cb27-18"></a>t.<span class="fu">join</span>()           <span class="co">// wait for the thread to terminate</span></span></code></pre></div>
<p>A thread <code>Runner</code> is started and loops until variable <code>done</code> is true. After printing a message, the main thread sets variable <code>done</code> to true and waits for <code>Runner</code> to terminate. As of this writing (Scala 2.13.1 and Java 13.0.1 on a Mac laptop), thread <code>Runner</code> keeps running and the program does not terminate. In other words, the main thread writes <code>true</code> in <code>done</code> but the other thread keeps reading <code>false</code> from the variable. There is no atomicity issue here (the Boolean is true or false, nothing in-between). The problem is the JMM, which does not guarantee that, absent synchronization, the value written in <code>done</code> by a thread can be seen by another thread.</p>
<p>If, in an attempt to debug the program, the <code>Runner</code> thread were to print the value of <code>done</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">while</span> (!done) {</span>
<span id="cb28-2"><a href="#cb28-2"></a>  <span class="fu">print</span>(done)</span>
<span id="cb28-3"><a href="#cb28-3"></a>}</span></code></pre></div>
<p>the program then terminates, using the same laptop, compiler and JVM as before (but it does not have to and could be non-terminating on the next run). Also, if the <code>println</code> statement (after the thread is started) is removed, the program does terminate on my laptop, even with an empty loop body in <code>Runner</code>. Debugging can be hard when bugs seem to disappear by adding or removing simple print statements!</p>
<p>To make it correct, the program should follow the rule that all accesses to shared mutable data are synchronized:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">var</span> done = <span class="kw">false</span></span>
<span id="cb29-2"><a href="#cb29-2"></a></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="kw">def</span> <span class="fu">terminate</span>() = synchronized {</span>
<span id="cb29-4"><a href="#cb29-4"></a>  done = <span class="kw">true</span></span>
<span id="cb29-5"><a href="#cb29-5"></a>}</span>
<span id="cb29-6"><a href="#cb29-6"></a></span>
<span id="cb29-7"><a href="#cb29-7"></a><span class="kw">def</span> isDone = <span class="fu">synchronized</span>(done)</span>
<span id="cb29-8"><a href="#cb29-8"></a></span>
<span id="cb29-9"><a href="#cb29-9"></a><span class="kw">class</span> Runner <span class="kw">extends</span> Runnable {</span>
<span id="cb29-10"><a href="#cb29-10"></a>  <span class="kw">def</span> <span class="fu">run</span>(): Unit = {</span>
<span id="cb29-11"><a href="#cb29-11"></a>    <span class="kw">while</span> (!isDone) {</span>
<span id="cb29-12"><a href="#cb29-12"></a>      <span class="co">// do something</span></span>
<span id="cb29-13"><a href="#cb29-13"></a>    }</span>
<span id="cb29-14"><a href="#cb29-14"></a>  }</span>
<span id="cb29-15"><a href="#cb29-15"></a>}</span>
<span id="cb29-16"><a href="#cb29-16"></a></span>
<span id="cb29-17"><a href="#cb29-17"></a><span class="kw">val</span> r = <span class="kw">new</span> Runner</span>
<span id="cb29-18"><a href="#cb29-18"></a><span class="kw">val</span> t = <span class="kw">new</span> Thread(r, <span class="st">&quot;Runner&quot;</span>)</span>
<span id="cb29-19"><a href="#cb29-19"></a></span>
<span id="cb29-20"><a href="#cb29-20"></a>t.<span class="fu">start</span>()</span>
<span id="cb29-21"><a href="#cb29-21"></a><span class="fu">println</span>(<span class="st">&quot;runner started at &quot;</span> + <span class="kw">new</span> java.<span class="fu">util</span>.<span class="fu">Date</span>())</span>
<span id="cb29-22"><a href="#cb29-22"></a></span>
<span id="cb29-23"><a href="#cb29-23"></a><span class="fu">terminate</span>()        <span class="co">// request termination</span></span>
<span id="cb29-24"><a href="#cb29-24"></a>t.<span class="fu">join</span>()           <span class="co">// wait for the thread to terminate</span></span></code></pre></div>
<p>This is now guaranteed to properly terminate.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>We assume this function to be in scope for all the examples in these notes.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>As I am typing these notes, the operating system of my MacBook reports 1592 threads running on 4 cores.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>There are other reasons this program can fail, related to the <em>Java Memory Model</em> (JMM) (see below). The lack of atomicity is the more crucial problem here.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<footer>2020-04-11 at 02:17:34 PM</footer>
</body>
