<!DOCTYPE html>
<!-- Generated from 904-parallel_server.md; DO NOT EDIT! -->
<html lang="en">
<head>
  <meta name="generator" content="pandoc">
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>22-parallel_server</title>
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans"/>
  <link rel="stylesheet" type="text/css" href="notes.css"/>
  </head>

<body>
<h2 id="case-study-a-parallel-server-using-futures-and-promises">Case Study: A Parallel Server Using Futures and Promises</h2>
<h3 id="illustration">Illustration</h3>
<p>Consider the implementation of a web server that processes incoming requests by performing a database lookup, using the result from this lookup to build a web page, adding a suitable advertisement to the page and sending the page back to the client. A simple server could be written as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> server<span class="op">:</span> ServerSocket <span class="op">=</span> <span class="op">...</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> connection <span class="op">=</span> <span class="kw">new</span> <span class="fu">Connection</span><span class="op">(</span>server<span class="op">.</span><span class="fu">accept</span><span class="op">())</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">processRequest</span><span class="op">(</span>connection<span class="op">)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">processRequest</span><span class="op">(</span>connection<span class="op">:</span> Connection<span class="op">):</span> <span class="bu">Unit</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> request <span class="op">=</span> connection<span class="op">.</span><span class="fu">read</span><span class="op">()</span>     <span class="co">// get request from client</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> data <span class="op">=</span> <span class="fu">dbLookup</span><span class="op">(</span>request<span class="op">)</span>        <span class="co">// search the database</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">addToLog</span><span class="op">(</span>data<span class="op">)</span>                      <span class="co">// log the results of the search</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> page <span class="op">=</span> <span class="fu">makePage</span><span class="op">(</span>data<span class="op">,</span> <span class="kw">new</span> <span class="fu">Ad</span><span class="op">())</span> <span class="co">// create an ad</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  connection<span class="op">.</span><span class="fu">write</span><span class="op">(</span>page<span class="op">)</span>              <span class="co">// reply to the client</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  connection<span class="op">.</span><span class="fu">close</span><span class="op">()</span>                  <span class="co">// close the socket</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">updateStats</span><span class="op">(</span>page<span class="op">)</span>                   <span class="co">// keep some stats</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This server processes requests sequentially: A thread—usually called <em>listening thread</em>—is blocked on <code>accept</code> until a client connects to the server. It then processes the request in <code>processRequest</code> before it goes back to <code>accept</code> to get the next client.</p>
<h3 id="parallel-server-java-style">Parallel server, Java style</h3>
<p>The previous implementation is <em>single-threaded</em>: the listening thread is doing all the work and processes all the requests sequentially. A classic (but somewhat old-fashioned) way to parallelize such a server is to create a new thread to handle each incoming connection:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> connection <span class="op">=</span> <span class="kw">new</span> <span class="fu">Connection</span><span class="op">(</span>server<span class="op">.</span><span class="fu">accept</span><span class="op">())</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> thread <span class="op">=</span> <span class="kw">new</span> <span class="fu">Thread</span><span class="op">(()</span> <span class="op">=&gt;</span> <span class="fu">processRequest</span><span class="op">(</span>connection<span class="op">))</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  thread<span class="op">.</span><span class="fu">start</span><span class="op">()</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The body of the loop, which is executed by the listening thread, takes very little time. The heavy lifting is done by a separate thread running the <code>processRquest</code> method. This makes it possible for a request to be processed in parallel with the listening task and with other requests.</p>
<h3 id="using-thread-pools">Using thread pools</h3>
<p>A more modern way to implement a server is to rely on a <em>thread pool</em>, used here as a collection of worker threads dedicated to the processing of requests.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> One benefit is that threads can be reused between requests (instead of having a thread terminate, then creating another one). Another is that the pool can place an upper bound on the number of threads and queue tasks when no thread is available (which tends to be more efficient and more robust than to create thousands of threads). Using thread pools can be done in Java or in Scala. In Scala, it would look like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> connection <span class="op">=</span> <span class="kw">new</span> <span class="fu">Connection</span><span class="op">(</span>server<span class="op">.</span><span class="fu">accept</span><span class="op">())</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  Future <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">processRequest</span><span class="op">(</span>connection<span class="op">)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Since the future returned by <code>Future</code> is not used, one could also call <code>execute</code> on the execution context directly:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>implicitly<span class="op">[</span>ExecutionContext<span class="op">].</span><span class="fu">execute</span><span class="op">(()</span> <span class="op">=&gt;</span> <span class="fu">processRequest</span><span class="op">(</span>connection<span class="op">))</span></span></code></pre></div>
<p>The server is now parallel and can handle multiple connections concurrently. Each connection, however, is still handled sequentially. If this is undesirable and hardware resources are available, a more responsive server can be obtained by processing some parts of a request in parallel.</p>
<h3 id="fetching-a-personalized-advertisement">Fetching a personalized advertisement</h3>
<p>Let us assume a method <code>fetchAdd</code> that can produce a customized advertisement based on the request:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">fetchAd</span><span class="op">(</span>request<span class="op">:</span> Request<span class="op">):</span> Ad <span class="op">=</span> <span class="op">...</span></span></code></pre></div>
<p>This method can be used when the page is assembled:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> page <span class="op">=</span> <span class="fu">makePage</span><span class="op">(</span>data<span class="op">,</span> <span class="fu">fetchAd</span><span class="op">(</span>request<span class="op">))</span></span></code></pre></div>
<p>Instead of calling <code>fetchAd</code> from the thread that is handling the connection, the ad can be fetched by a separate thread while the connection handling thread is doing the database lookup and the logging. After the ad is loaded, it can be combined with the database data to form a page, which is returned to the client:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">processRequest</span><span class="op">(</span>connection<span class="op">:</span> Connection<span class="op">):</span> <span class="bu">Unit</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> request <span class="op">=</span> connection<span class="op">.</span><span class="fu">read</span><span class="op">()</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> futureAd <span class="op">=</span> <span class="fu">Future</span><span class="op">(</span><span class="fu">fetchAd</span><span class="op">(</span>request<span class="op">))</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> data <span class="op">=</span> <span class="fu">dbLookup</span><span class="op">(</span>request<span class="op">)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">addToLog</span><span class="op">(</span>data<span class="op">)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>ad <span class="op">&lt;-</span> futureAd<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> page <span class="op">=</span> <span class="fu">makePage</span><span class="op">(</span>data<span class="op">,</span> ad<span class="op">)</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    connection<span class="op">.</span><span class="fu">write</span><span class="op">(</span>page<span class="op">)</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    connection<span class="op">.</span><span class="fu">close</span><span class="op">()</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">updateStats</span><span class="op">(</span>page<span class="op">)</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the connection handling thread is doing the calls to <code>read</code> and to <code>dbLookup</code>. The call to <code>fetchAd</code> is run by another thread from the execution context. The rest of the code (page creation, logging and response to the client) runs in an unspecified thread.</p>
<h3 id="handling-a-request-with-maximum-parallelism">Handling a request with maximum parallelism</h3>
<p>Other parts of the request can be performed in parallel if desired. The dependency graph is as follows:</p>
<p><img src="Images/tasks.png" class="centered" /></p>
<p>If any task that can run asynchronously is scheduled on the thread pool, the implementation of method <code>processRequest</code> may look like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">processRequest</span><span class="op">(</span>connection<span class="op">:</span> Connection<span class="op">):</span> <span class="bu">Unit</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> futureRequest <span class="op">=</span> <span class="fu">Future</span><span class="op">(</span>connection<span class="op">.</span><span class="fu">read</span><span class="op">())</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> futureAd <span class="op">=</span> futureRequest map fetchAd</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> futureData <span class="op">=</span> futureRequest map dbLookup</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>data <span class="op">&lt;-</span> futureData<span class="op">)</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">addToLog</span><span class="op">(</span>data<span class="op">)</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> futurePage <span class="op">=</span> <span class="cf">for</span> <span class="op">(</span>data <span class="op">&lt;-</span> futureData<span class="op">;</span> ad <span class="op">&lt;-</span> futureAd<span class="op">)</span> <span class="cf">yield</span> <span class="fu">makePage</span><span class="op">(</span>data<span class="op">,</span> ad<span class="op">)</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>page <span class="op">&lt;-</span> futurePage<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    connection<span class="op">.</span><span class="fu">write</span><span class="op">(</span>page<span class="op">)</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    connection<span class="op">.</span><span class="fu">close</span><span class="op">()</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>page <span class="op">&lt;-</span> futurePage<span class="op">)</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">updateStats</span><span class="op">(</span>page<span class="op">)</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the thread that runs this method does not do any of the work itself but schedules everything on the underlying thread pool. In other words, method <code>processRequest</code> returns immediately. Accordingly, it does not need to be called asynchronously anymore and the listening loop can simply be written as:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">processRequest</span><span class="op">(</span><span class="kw">new</span> <span class="fu">Connection</span><span class="op">(</span>server<span class="op">.</span><span class="fu">accept</span><span class="op">()))</span></span></code></pre></div>
<p>Note also that the calls to <code>map</code> could be written as <code>for/yield</code> instead, e.g.:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> futureAd <span class="op">=</span> <span class="cf">for</span> <span class="op">(</span>request <span class="op">&lt;-</span> futureRequest<span class="op">)</span> <span class="cf">yield</span> <span class="fu">fetchAd</span><span class="op">(</span>request<span class="op">)</span></span></code></pre></div>
<h3 id="dealing-with-errors">Dealing with errors</h3>
<p>A more realistic server would have to deal with errors. For instance, if a proper page cannot be constructed, the client should still receive a reply, possibly with explanations regarding the error. The code:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>page <span class="op">&lt;-</span> futurePage<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  connection<span class="op">.</span><span class="fu">write</span><span class="op">(</span>page<span class="op">)</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  connection<span class="op">.</span><span class="fu">close</span><span class="op">()</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>will not send any reply if <code>futurePage</code> fails to produce a page. Instead, one could use <code>onComplete</code> to deal with both the successful and the failed cases:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>futurePage onComplete <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="fu">Success</span><span class="op">(</span>page<span class="op">)</span> <span class="op">=&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    connection<span class="op">.</span><span class="fu">write</span><span class="op">(</span>page<span class="op">)</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    connection<span class="op">.</span><span class="fu">close</span><span class="op">()</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> <span class="fu">Failure</span><span class="op">(</span>e<span class="op">)</span> <span class="op">=&gt;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    connection<span class="op">.</span><span class="fu">write</span><span class="op">(</span><span class="kw">new</span> <span class="fu">FailureMessage</span><span class="op">(</span>e<span class="op">))</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    connection<span class="op">.</span><span class="fu">close</span><span class="op">()</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Another way to achieve the same behavior is to transform a failure to create a page into a failure message page, then process it as a regular page:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> futurePage <span class="op">=</span> <span class="op">(</span><span class="cf">for</span> <span class="op">(</span>data <span class="op">&lt;-</span> futureData<span class="op">;</span> ad <span class="op">&lt;-</span> futureAd<span class="op">)</span> <span class="cf">yield</span> <span class="fu">makePage</span><span class="op">(</span>data<span class="op">,</span> ad<span class="op">))</span> recover <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> e <span class="op">=&gt;</span> <span class="kw">new</span> <span class="fu">FailureMessage</span><span class="op">(</span>e<span class="op">)</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Instead of <code>recover</code>, method <code>fallbackTo</code> can be used to handle the failed case with a new asynchronous computation that will produce a replacement.</p>
<p>Of course, more complicated error handling schemes could differentiate between request reading failure, database failure, ad fetching failure, etc.</p>
<h3 id="using-a-default-advertisement">Using a default advertisement</h3>
<p>Imagine the scenario in which database lookup can be completed in one second, but fetching a customized ad takes ten seconds. In that case, it might be better to send a reply with a default, non-customized ad after one second than wait ten seconds for a better ad.</p>
<p>A simple approach would be to use another future on a task that waits for a maximum acceptable delay and then produces a default ad:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> futureAdFetched <span class="op">=</span> futureRequest map fetchAd</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> futureAdDefault <span class="op">=</span> futureRequest map <span class="op">{</span> _ <span class="op">=&gt;</span> SECONDS<span class="op">.</span><span class="fu">sleep</span><span class="op">(</span>maxDelay<span class="op">);</span> <span class="kw">new</span> DefaultAd <span class="op">}</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> futureAd <span class="op">=</span> Future<span class="op">.</span><span class="fu">firstCompletedOf</span><span class="op">(</span><span class="bu">List</span><span class="op">(</span>futureAdFetched<span class="op">,</span> futureAdDefault<span class="op">))</span></span></code></pre></div>
<p>A drawback to this approach is that it blocks a thread from the working pool on <code>sleep</code>, thus reducing the number of available workers for a while. Some thread pools, including the default one, use a mechanism by which new threads are created if workers get blocked in order to maintain a desired level of parallelism. To trigger this mechanism, user code needs to declare explicitly that it might be blocking:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> futureAdDefault <span class="op">=</span> futureRequest map <span class="op">{</span> _ <span class="op">=&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  blocking <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    SECONDS<span class="op">.</span><span class="fu">sleep</span><span class="op">(</span>maxDelay<span class="op">)</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">new</span> DefaultAd</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Still, a better approach is to rely on a timer to send a signal after the delay has elapsed. This way, no threads are needlessly blocked on <code>sleep</code>.</p>
<p>Scala has no native timer facility, but Java’s <code>ScheduledExecutorService</code> can be used:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> timer <span class="op">=</span> Executors<span class="op">.</span><span class="fu">newScheduledThreadPool</span><span class="op">(</span><span class="dv">1</span><span class="op">)</span></span></code></pre></div>
<p>This timer uses only one additional thread for all the timeouts in the server (scheduled thread pools can be created with more threads if needed). Its <code>schedule</code> method returns a Java <code>Future</code>, which is different from a Scala <code>Future</code> and thus cannot be easily fed into <code>firstCompletedOf</code>. Instead, the timer can be used to complete a <code>Promise</code>, thus resulting in a proper Scala <code>Future</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> promiseAd <span class="op">=</span> Promise<span class="op">[</span>Ad<span class="op">]</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> futureAd <span class="op">=</span> promiseAd<span class="op">.</span>future</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>request <span class="op">&lt;-</span> futureRequest<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> deadline <span class="op">=</span> timer<span class="op">.</span><span class="fu">schedule</span><span class="op">(()</span> <span class="op">=&gt;</span> promiseAd<span class="op">.</span><span class="fu">trySuccess</span><span class="op">(</span><span class="kw">new</span> DefaultAd<span class="op">),</span> maxDelay<span class="op">,</span> SECONDS<span class="op">)</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  promiseAd<span class="op">.</span><span class="fu">trySuccess</span><span class="op">(</span><span class="fu">fetchAd</span><span class="op">(</span>request<span class="op">))</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  deadline<span class="op">.</span><span class="fu">cancel</span><span class="op">(</span><span class="kw">true</span><span class="op">)</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If an ad can be fetched in time, the timer action is not needed and is cancelled (Java’s <code>Future</code> has a <code>cancel</code> method that Scala’s <code>Future</code> is lacking).</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p> Although such a pool can also be shared with other components on the application, if any.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<footer>2021-04-27 at 01:48:06 PM</footer>
</body>
